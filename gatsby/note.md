Gatsby is a framework for building a modern website.
gatsby use react under the hood, it is very fast, why it's like that because it static site generator or pregenerator there is build stack in your website.
gatsby knows what the css is needed, so he reload the css when it's need to show up as fast as possible before the content loaded

gatsby ialah static site generator, yang membuat sebuah website dynamic menjadi static agar lebih cepat dimuat oleh browser.
struktur foldernya berupa pages dimana tempat meload halaman halaman website. lalu ada components untuk menyimpan component component yang bisa digunakan setiap saat pada page manapun. setelah itu ada assets tempat menyimpan source berupa images, font, dll.
gatsby juga membuat folder styles untuk global style dari module styled component.

menariknya, dengan gatsby kita tidak perlu lagi menggunakan react router dom untuk merouter / mengarahkan halaman perhalaman, gatsby hanya perlu Link komponent dan bisa membuat layout yang sekiranya butuh ditampilkan pada semua halaman dengan merangkap halaman mana yang akan menjadi childrennya. seperti navbar dan footer yang selalu ada pada setiap halaman. yaitu dengan cara konfigurasi gatsby pada file gasby-browser di root folder dengan membuat fungsi wrapPageElement() dan gunakan komponent Layout beserta childrennya. maka, otomatis gatsby melakukan route pada seluruh file pages kita sebagai children dari Layout yang telah kita buat beserta navbar dan footernya. hal ini sama seperti menggunakan react-router-dom dan akan kita bahas lebih lanjut nanti.

gatsby juga support styled.component yang sangat berguna membuat komponent dengan style css. serta menggunakan graphql sesuatu yang menjadi keunggulan gatsby.
graphql adalah formasi API terbaru yang lebih fungsionalitas dibandingkan REST API standar. tidak seperti REST kita harus membuat fungsi untuk menangani endpoint pada tiap request seperti POST, GET dll. graphql hanya perlu membuat satu query dan kita bisa melakukan semua yang dilakukan REST tanpa membuat endpoint dibackend karena gatsby telah melakukannya untuk kita.

agar gatsby bisa menggunakan graphql kita perlu sebuah tempat untuk menyimpan data yang disebut cms, salah satunya kita bisa menggunakan sanity, dan setelah data dibuat gatsby memerlukan config pada file gatsby-config yang berupa akses json untuk sanity. lalu pada page kita bisa langsung menggunakan module graphql dari gatsby dan menjalankan query graphql untuk memuat data dan menggunakan data pada jsx. konfigurasi tersebut menggunakan plugins yang telah disediakan oleh gatsbyjs.

karena static maka untuk meload page hasilnya pun sangat memuaskan, bukan hanya itu gatsby juga meload suatu image yang berukuran besar menjadi lebih cepat, yang mana kita tahu jika suatu web dipenuhi dengan image yang tidak diminimalisir akan membuat suatu web menjadi lama diload. tetapi tidak dengan gatsby, karena gatsby membuat image diload hanya jika diperlukan dan sumbernya pun tidak langsung image melainkan hanya potongan icon yang sangat kecil. untuk melakukan hal tersebut membutuhkan konfigurasi yang telah disediakan oleh gatsby dengan plugin-pluginnya berupa gatsby-image API.

gatsby telah menangani route tiap pagenya dengan file yang ada didalam folder pages. apapun endpoint pada site akan otomatis merefer pada file component yang ada di dalam filder pages. namun jika file dengan endpoint tersebut tidak ada dalam pages hasilnya akan not found dan kita bisa membuat file 404.js untuk menghandlenya, akan tetapi didalam file 404 tersebut merupakan fungsi dengan nama yang tidak harus sama dengan nama file. karena nama fungsi dalam javascript tidak boleh dengan angka.

dengan Link komponent dari gatsby juga kita bisa mengecek route, params, dan path seperti yang dilakukan react-router-dom. kita bisa menavigate ke endpoint tertentu dan menyisipkan params kedalamnya. hal itu dikarenakan gatsby telah membuat semua file pada folder pages dan menyisipkan properties seperti router pada komponent tersebut, jadi hanya file komponent didalam folder pages tersebut yang mempunyai properties route. gatsby menggunakan react router dan mengkonfiguarsinya agar lebih mudah digunakan tanpa perlu meroute tiap page.

gatsby juga bisa membuat page secara dynamic, yang berarti bahwa semua link yang memiliki slug atau yang mengarah ke suatu halaman akan dibuatkan sebuah page secara otomatis yaitu dengan memanfaatkan sebuah template page pada folder template. biasanya pada react router tiap tiap slug pada suatu endpoint hanya menggunakan satu halaman lalu javascript akan memfetch data berdasarkan slug tersebut. kendalanya akan terjadi delay loading sesaat dilakukannya fetching data tersebut. namun tidak dengan gatsby yang memang berkonsep static site generator, jadi semua halaman maupun data akan dibuat menjadi static terlebih dahulu. dengan dynamic page semua endpoint yang merefer kpd slug tertentu tetap akan memfetching data, namun proses tersebut dilakukan sebelum gatsby meload halaman.

untuk dapat menggunakan dynamic page kita memerlukan konfigurasi terlebih dahulu. gatsby menyediakan api gatsby-node pada root folder yang berisi hook createPages. createPages memiliki parameter berupa objek yang tediri dari graphql dan action. objek parameter graphql untuk memfetching data-data yang diperlukan berdasarkan endpoint/slug dan objek parameter actions ialah objek yang memiliki fungsi createPage(). setelah hook createPages mengeksekusi graphql, data berupa nodes didapatkan kemudian dilakukannya looping yang memanggil actions.createPage. disinilah proses pembuatan halaman dinamis, createPage() memerlukan konfigurasi berupa objek yang terdiri dari path, component, dan context.

path ialah untuk menghandle url endpoint tiap slug, komponent dimaksudkan untuk templating page komponent mana yang ingin digunakan pada kasus ini diperlukan api dari node yaitu path untuk mengarah kepada source file template, dan context ialah untuk menyisipkan data pada template yang kita gunakan sehingga dari file template kita bisa memfetching data sesuai dengan params yang telah disisipkan oleh context createPage. karena graphql gatsby pada saat melakukan query bisa menggunakan variabel seperti yang telah dikirim dari createPage melalui properties contextnya. variabel tersebut bisa digunakan untuk filter pada fields data query. namun perlu diingat saat mendefinisikan variabel harus diawali dengan $ dan disertai tipe datanya, sbb "$nama : String!". Apabila data yang ingin disisipkan berupa number maka tipe datanya ialah Int.

gatsby juga dapat menghandle REST API, data json hasil fetching REST akan dimodifikasi oleh gatsby menjadi graphql jadi akan lebih mudah untuk melakukan query pada REST data json. untuk melakukan hal tersebut diperlukan konfigurasi pada gatsby-node, di file ini kita tidak bisa melakukan fetch seperti file javascript frontend melainkan harus menggunakan fetch api dari beberapa modul seperti node-fetch dsb. fetching REST API dilakukan didalam hook fungsi yang bernama sourceNodes() yang memiliki parameter berupa objek. objek tersebut berisi actions, createNodeId(), dan createContentDigest(). actions juga berupa objek yang mengandung fungsi createNode(), setelah fetch api dilakukan dan data jsonnya pun diloop untuk mengambil masing masing objeknya untuk dimasukannya satu persatu kedalam graphql dengan menggunakan createNode().

namun graphql sendiri mempunyai stuktur datanya sendiri, yaitu berupa id, parent, children, dan internal. id bisa dibuat dengan parameter objek kedua yaitu createNodeId(), parent biasa digunakan apabila data json tersebut mempunyai relasi dengan objek lain, children untuk defaultnya diisi dengan empty array saja.
dan di internal properties berisi objek yang merupakan keterangan objek dari REST. terdiri dari type yaitu untuk penamaan di graqhicQL, mediaType sama seperti contentType yaitu bisa application/json, text/html dll. properties content bisa berisi objek res json dan contentDigest diisi dengan objek ketiga dari parameter hook fungsi yaitu createContentDigest().

setelah objek baru dibuat pada saat looping data json dieksekusilah fungsi objek pertama dari hook sourceNodes yang bernama actions.createNode(). didalam fungsinya dispread objek yang telah dibuat tadi dan juga objek loop data json nya. data REST pun telah siap dalam format graphql, kita bisa mengeceknya di grahiQL dan data sudah ada sesuai dengan value yang diisikan dalam properties type pada objek internal. kita juga bisa membuat pagination dengan bantuan createPages() dari gatsby. mengingat gatsby adalah static site generator, semua url bahkan dalam pagination itu perlu dilakukannya generate data ke static page.

di file root .env pun kita juga bisa mengambil data yang disimpan kedalam gatsby frontend src folder. akan tetapi ada syarat dalam penamaan variabelnya harus diawali dengan kata GATSBY, ex: GATSBY_PAGE_SIZE. pagination lebih mudah karena pada saat melakukan query graphql telah menghitung total data nodesnya dengan properti totalCount. dengan demikian totalCount tersebut bisa langsung dimanfaatkan untuk looping proses generating. untuk data yang dikirimkan ke frontend code ialah limit, skip, currentPage, dll tergantung keperluan. karena query graphql memiliki parameter untuk melakukan pagination dengan melimit dan skip data berdasarkan variabel tersebut sebelumnya pastikan tipe datanya ialah Int.

gatsby juga bisa optimasi SEO yaitu dengan menggunakan plugins react-helmet. untuk menggunakan plugin react-helmet diperlukan konfigurasi plugins pada file gatsby-config. file gatsby config ini juga bisa menyimpan objek yang nantinya bisa dilakukan query untuk pemanggilannya. hal itu berguna untuk menyimpan semua informasi pada site yang akan dimanfaatkan juga oleh optimasi SEO react-helmet. react helmet nantinya akan dipanggil kedalam tiap tiap komponent, maka dari itu lebih baik dibuat menjadi satu komponent SEO. file SEO berisi tag helmet yang didalamnya diisikan title, meta tag dll. tag helmet juga memiliki properties seperti titleTemplate. titleTemplate nantinya menjadi output tambahan dari title yang kita buat, dan juga bisa menampung variable untuk output title tertentu. sebagai contoh "%s - title template". penyimpanan variable pada titleTemplate diawali dengan tanda % dan s untuk nama variabel yang nanti ouputnya ialah isi dari tag title.

Gatsby juga memudahkan kita untuk melakukan state manajemen, yaitu dengan menggunakan hook createContext built in react. sama seperti aturan dalam react standar context API harus menjadi parent dari root app. namun pada gatsby cara merangkap app dengan context ada pada konfigurasi gatsby-browser. dengan memanfaatkan hook wrapRootElement() yang berisikan parameter objek element, kita hanya perlu mereturn konteks provider dengan children element. maka otomatis gatsby membuat seluruh isi root app kita dirangkap oleh context api dan data nya pun siap digunakan dengan useContext.

gatsby makin power full dengan adanya konfigurasi serverless, untuk handle mailer dan hal hal backend lainnya. disupport dengan netlify keperluan backend terasa lebih mudah. untuk konfigurasinya memerlukan netlify-cli, file netlify.toml yang berada di root dan folder functions yang nantinya akan berisi file file serverless. netlify.toml berisi instruksi agar gatsby bisa mengeksekusi file functions, dan di dalam folder functions bisa berupa file javascript langsung ataupun sub folder yang di dalamnya baru kemudian ada file javascript dengan nama sama persis seperti folder parentnya. agar konfigurasi serverless bisa dieksekusi oleh gatsby, isi file javascript tersebut harus di exports objek dengan cara exports standar javascript bukan dengan cara export es module. dan objek propertinya bernama handler yang juga berisi fungsi yang memiliki dua parameter yaitu event dan context. exports.handler functionnya harus asyncronous jadi jangan lupa menambahkan async.

jika ingin melakukan mailing otomatis dari server kita memerlukan module nodemailer yang bisa diinstal packagenya melalui npm didalam folder functions. setelah instalasi, file javascript yang dibuat didalam folder functions ataupun dalam subfolder functions diisikan setup nodemailer berupa require module. perlu diingat untuk serverless ini tidak bisa menggunakan es module import export tapi hanya bisa menggunakan require dan exports. nodemailer memiliki objek yang berupa fungsi yaitu createTransport(). pada fungsi tersebut diperlukan parameter yang berupa objek dengan properti seperti (host, port) / service, dan auth. host, port atau service ialah nama host seperti gmail, etherial, smntp dll. sedangkan auth berupa objek yang berisi user serta pass. disinilah proses login pada email service kita.

setelah itu fungsi tersebut mereturn sebuah objek yang memiliki fungsi sendMail(). inilah saat kita mengirim data data seperti pengirim, penerima, subjek, dan isi email. sendMail() memiliki parameter pertama berupa objek yang berisi from, to, subject, text, dan html. pada properti html kita bisa mengisi dengan seperti file html biasa. dan parameter kedua bisa diisi dengan callback function() yang akan dieksekusi setelah proses mailing selesai. apabila parameter kedua tidak diisi maka sendMail() akan mereturn sebuah objek yang berisi tentang status email tersebut. hal yang perlu diingat yaitu pemanggilan sendMail() ini harus didalam exports.handler agar gatsby bisa mengenalinya sebagai konfigurasi serverless. dan lalu direturn objek berupa statusCode, dan body sebagai informasi ke user client.

untuk mengirimkan data dari frontend ke backend serverless folder functions bekerja seperti endpoint yang nantinya url fetch akan diarahkan kepada folder/subfolder tersebut. function fetch bisa bierisi dua parameter, yang pertama adalah alamat url dan yang kedua adalah objek yang berisi keterangan berupa method, headers, dan body. method bisa berupa GET ataupun POST, headers berisi json objek yang memiliki key Content-Type dan diisikan dengan tipenya misal application/json, text/html dll. lalu body itu berupa data objek yang ingin kita kirimkan, dan jika itu objek maka harus diubah menjadi string terlebih dahulu yaitu dengan JSON.stringify(). fetch() fungsi juga merupakan asycn function yang berarti proses pengeksekusian dilakukan tanpa menunda proses/perintah selanjutnya, dan jika disimpan kedalam variabel ini maka hasilnya akan mereturn promise.

untuk itu promise/asnyc function harus diikuti dengan .then() untuk meresult ataupun .catch() untuk menangkap apabila terjadinya error. jika fetch() ingin disimpan dalam suatu variabel yang agar nantinya bisa digunakan pada hal lain maka harus diawali dengan keyword await sebelum fetch(). akan tetapi pada parent function juga harus diawali keyword async yang menandakan bahwa ada asyncronous method didalam fungsi tersebut. output dari fetch() berasal dari backend yang telah mendapatkan data dan memanipulasinya pada saat dilakukannya fetch(). pada gatsby saat dilakukannya fetching data, file javascript yang ada difolder functions yang juga merupakan url pada fetch() akan menerima data kiriman dalam fungsi exports.handler(). didalam fungsi inilah data akan dieksekusi dan gatsby telah membuatnya menjadi mudah. data kirman akan disimpan/ditangkap dalam objek properti event pada parameter exports.handler() yaitu event.body dan datanyapun berupa string karena pada saat dikirim dari frontend telah dikonversi dengan JSON.stringify() karena untuk proses transfer data dari frontend ke backend atau sebaliknya diharuskan berupa string.

jika ingin memanipulasi data maka harus dibuat menjadi objek terlebih dahulu, itu bisa dilakukan dengan JSON.parse(). setelah itu kita bisa melakukan banyak hal terkait serverless seperti menjalankan sendMail() dan menggunakan objek data kirimiman kedalam objek parameter fungsi sendMail(). kita juga bisa melakukan verifikasi yang apabila syarat tidak terpenuhi maka akan mengembalikan data error kepada frontend. untuk mengirim data kembalian kepada frontend didalam exports.handler() harus mereturn objek yang berupa statusCode, body, dan informasi penting lainnya. statusCode ialah kode hasil dari proses fetching tersebut, lalu value dari body nantinya akan bisa ditangkap dan menjadi nilai kembalian dari backend pada fetch() dan biasanya berupa objek yang juga telah dan harus dikonversi menjadi string dengan JSON.stringify(), sama pada saat mengirim data/fetching dari frontend ke backend. karena itu jika data kembalian ingin dimanfaatkan oleh frontend maka lebih mudah apabila dikonversi kembali menjadi objek dengan JSON.parse().

honeypot adalah istilah dari menjebak sebuah robot/bot pada website, karena biasa nya bot akan otomatis mengisi semua form dan melakukan submit dengan jumlah yang tidak kira2 yang akan membuat server kita manjadi down. untuk itu kita perlu mengetahuinya dengan menyisipkan sebuah form input yang memang seharusnya kosong tidak bisa diinput oleh user karena keberadaannya yang tidak terlihat. sebuah bot tidak akan menyadari itu karena dia mengisi seluruh form baik yang terlihat maupun yang tidak terlihat. saat kondisi itu terpenuhi maka server bisa mengetahui bahwa ada bot yang mencoba mengisi form dan akan mengembalikan nilai error. dengan manipulasi css kita bisa membuat form input ini tidak terlihat namun jangan sampai berbeda dengan form lainnya sehingga memungkinkan bot tahu kalau itu jebakan.
